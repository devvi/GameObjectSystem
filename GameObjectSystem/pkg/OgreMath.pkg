namespace Ogre
{
	
	class Radian
	{
	public:
		Radian ( Real r=0 );
		Radian ( const Degree& d );
		Radian& operator = ( const Real& f );
		Radian& operator = ( const Radian& r );
		Radian& operator = ( const Degree& d );

		Real valueDegrees() const; 
		Real valueRadians() const;
		Real valueAngleUnits() const;

        const Radian& operator + () const;
		Radian operator + ( const Radian& r ) const;
		Radian operator + ( const Degree& d ) const;
		Radian& operator += ( const Radian& r );
		Radian& operator += ( const Degree& d );
		Radian operator - () const;
		Radian operator - ( const Radian& r ) const;
		Radian operator - ( const Degree& d ) const;
		Radian& operator -= ( const Radian& r );
		Radian& operator -= ( const Degree& d );
		Radian operator * ( Real f ) const;
        Radian operator * ( const Radian& f );
		Radian& operator *= ( Real f );
		Radian operator / ( Real f ) const ;
		Radian& operator /= ( Real f ) ;

		bool operator <  ( const Radian& r ) const;
		bool operator <= ( const Radian& r ) const;
		bool operator == ( const Radian& r ) const;
		bool operator != ( const Radian& r ) const;
		bool operator >= ( const Radian& r ) const;
		bool operator >  ( const Radian& r ) const;
	};

    
	class Degree
	{
	public:
		Degree ( Real d=0 );
		Degree ( const Radian& r );
		Degree& operator = ( const Real& f );
		Degree& operator = ( const Degree& d );
		Degree& operator = ( const Radian& r );

		Real valueDegrees() const;
		Real valueRadians() const; 
		Real valueAngleUnits() const;

		const Degree& operator + () const;
		Degree operator + ( const Degree& d ) const;
		Degree operator + ( const Radian& r ) const;
		Degree& operator += ( const Degree& d );
		Degree& operator += ( const Radian& r );
		Degree operator - () const;
		Degree operator - ( const Degree& d ) const;
		Degree operator - ( const Radian& r ) const;
		Degree& operator -= ( const Degree& d );
		Degree& operator -= ( const Radian& r );
		Degree operator * ( Real f ) const;
        Degree operator * ( const Degree& f ) const;
		Degree& operator *= ( Real f );
		Degree operator / ( Real f ) const;
		Degree& operator /= ( Real f );

		bool operator <  ( const Degree& d ) const ;
		bool operator <= ( const Degree& d ) const ;
		bool operator == ( const Degree& d ) const ;
		bool operator != ( const Degree& d ) const ;
		bool operator >= ( const Degree& d ) const ;
		bool operator >  ( const Degree& d ) const ;

	};
	
	class Angle
	{
	public:
		Angle ( Real angle );
		operator Radian() const;
		operator Degree() const;
	};

    class Math 
    {
   public:
       enum AngleUnit
       {
           AU_DEGREE,
           AU_RADIAN
       };
    public:
        Math(unsigned int trigTableSize = 4096);

        /** Default destructor.
        */
        ~Math();

		static inline Real DegreesToRadians(Real degrees) { return degrees * fDeg2Rad; }
        static inline Real RadiansToDegrees(Real radians) { return radians * fRad2Deg; }

    
       static void setAngleUnit(AngleUnit unit);
    
       static AngleUnit getAngleUnit(void);

       static Real AngleUnitsToRadians(Real units);
    
       static Real RadiansToAngleUnits(Real radians);
      
       static Real AngleUnitsToDegrees(Real units);
     
       static Real DegreesToAngleUnits(Real degrees);

       static bool pointInTri2D(const Vector2& p, const Vector2& a, 
			const Vector2& b, const Vector2& c);

       static bool pointInTri3D(const Vector3& p, const Vector3& a, 
		const Vector3& b, const Vector3& c, const Vector3& normal);
       
        /** Calculates the tangent space vector for a given set of positions / texture coords. */
        static Vector3 calculateTangentSpaceVector(
            const Vector3& position1, const Vector3& position2, const Vector3& position3,
            Real u1, Real v1, Real u2, Real v2, Real u3, Real v3);

        /** Calculate a face normal, including the w component which is the offset from the origin. */
        static Vector4 calculateFaceNormal(const Vector3& v1, const Vector3& v2, const Vector3& v3);
        /** Calculate a face normal, no w-information. */
        static Vector3 calculateBasicFaceNormal(const Vector3& v1, const Vector3& v2, const Vector3& v3);
        /** Calculate a face normal without normalize, including the w component which is the offset from the origin. */
        static Vector4 calculateFaceNormalWithoutNormalize(const Vector3& v1, const Vector3& v2, const Vector3& v3);
        /** Calculate a face normal without normalize, no w-information. */
        static Vector3 calculateBasicFaceNormalWithoutNormalize(const Vector3& v1, const Vector3& v2, const Vector3& v3);

		/** Generates a value based on the Gaussian (normal) distribution function
			with the given offset and scale parameters.
		*/
		static Real gaussianDistribution(Real x, Real offset = 0.0f, Real scale = 1.0f);

		static Matrix4 makeViewMatrix(const Vector3& position, const Quaternion& orientation, 
			const Matrix4* reflectMatrix = 0);


    };


}
#endif
